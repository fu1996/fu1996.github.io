"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3324],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=u(n),c=i,h=d["".concat(s,".").concat(c)]||d[c]||p[c]||r;return n?a.createElement(h,l(l({ref:t},m),{},{components:n})):a.createElement(h,l({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var u=2;u<r;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},58232:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var a=n(87462),i=(n(67294),n(3905));const r={authors:"junkui",title:"normalizr\u7684\u5b98\u65b9API",categories:["js","work"],tags:["js","work","normalizr"],date:new Date("2021-03-17T09:50:59.000Z")},l="API",o={permalink:"/blog/normalizr\u7684\u5b98\u65b9API",source:"@site/blog/normalizr\u7684\u5b98\u65b9API.md",title:"normalizr\u7684\u5b98\u65b9API",description:"- normalize",date:"2021-03-17T09:50:59.000Z",formattedDate:"2021\u5e743\u670817\u65e5",tags:[{label:"js",permalink:"/blog/tags/js"},{label:"work",permalink:"/blog/tags/work"},{label:"normalizr",permalink:"/blog/tags/normalizr"}],readingTime:11.495,hasTruncateMarker:!1,authors:[{name:"\u4ed8\u4fca\u594e",title:"\u4e00\u540d\u5728\u5927\u5b66\u4ece\u52a8\u7269\u79d1\u5b66\u4e13\u4e1a\u8f6c\u7801\u519c\u7684\u81ea\u5b66\u8005",url:"https://github.com/fu1996",imageURL:"https://avatars.githubusercontent.com/u/42232973",key:"junkui"}],frontMatter:{authors:"junkui",title:"normalizr\u7684\u5b98\u65b9API",categories:["js","work"],tags:["js","work","normalizr"],date:"2021-03-17T09:50:59.000Z"},prevItem:{title:"\u4e0d\u591f\u7ec6\u8282\u5bfc\u81f4\u7684BUG",permalink:"/blog/\u4e0d\u591f\u7ec6\u8282\u5bfc\u81f4\u7684BUG"},nextItem:{title:"normalizr\u683c\u5f0f\u5316\u6570\u636e\u5229\u5668",permalink:"/blog/normalizr\u683c\u5f0f\u5316\u6570\u636e\u5229\u5668"}},s={authorsImageUrls:[void 0]},u=[{value:"<code>normalize(data, schema)</code>",id:"normalizedata-schema",level:2},{value:"Usage",id:"usage",level:3},{value:"Output",id:"output",level:3},{value:"<code>denormalize(input, schema, entities)</code>",id:"denormalizeinput-schema-entities",level:2},{value:"Usage",id:"usage-1",level:3},{value:"Output",id:"output-1",level:3},{value:"<code>schema</code>",id:"schema",level:2},{value:"<code>Array(definition, schemaAttribute)</code>",id:"arraydefinition-schemaattribute",level:3},{value:"Instance Methods",id:"instance-methods",level:4},{value:"Usage",id:"usage-2",level:4},{value:"Output",id:"output-2",level:4},{value:"Output",id:"output-3",level:4},{value:"<code>Entity(key, definition = {}, options = {})</code>",id:"entitykey-definition---options--",level:3},{value:"Instance Methods",id:"instance-methods-1",level:4},{value:"Instance Attributes",id:"instance-attributes",level:4},{value:"Usage",id:"usage-3",level:4},{value:"Output",id:"output-4",level:4},{value:"<code>idAttribute</code> Usage",id:"idattribute-usage",level:4},{value:"Output",id:"output-5",level:4},{value:"<code>fallbackStrategy</code> Usage",id:"fallbackstrategy-usage",level:4},{value:"Output",id:"output-6",level:4},{value:"<code>Object(definition)</code>",id:"objectdefinition",level:3},{value:"Instance Methods",id:"instance-methods-2",level:4},{value:"Usage",id:"usage-4",level:4},{value:"Output",id:"output-7",level:4},{value:"<code>Union(definition, schemaAttribute)</code>",id:"uniondefinition-schemaattribute",level:3},{value:"Instance Methods",id:"instance-methods-3",level:4},{value:"Usage",id:"usage-5",level:4},{value:"Output",id:"output-8",level:4},{value:"<code>Values(definition, schemaAttribute)</code>",id:"valuesdefinition-schemaattribute",level:3},{value:"Instance Methods",id:"instance-methods-4",level:4},{value:"Usage",id:"usage-6",level:4},{value:"Output",id:"output-9",level:4},{value:"Output",id:"output-10",level:4}],m={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#normalizedata-schema"},"normalize")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#denormalizeinput-schema-entities"},"denormalize")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#schema"},"schema"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#arraydefinition-schemaattribute"},"Array")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#entitykey-definition---options--"},"Entity")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#objectdefinition"},"Object")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#uniondefinition-schemaattribute"},"Union")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#valuesdefinition-schemaattribute"},"Values"))))),(0,i.kt)("h2",{id:"normalizedata-schema"},(0,i.kt)("inlineCode",{parentName:"h2"},"normalize(data, schema)")),(0,i.kt)("p",null,"Normalizes input data per the schema definition provided."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"data"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," Input JSON (or plain JS object) data that needs normalization."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schema"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," A schema definition")),(0,i.kt)("h3",{id:"usage"},"Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { normalize, schema } from "normalizr";\n\nconst myData = { users: [{ id: 1 }, { id: 2 }] };\nconst user = new schema.Entity("users");\nconst mySchema = { users: [user] };\nconst normalizedData = normalize(myData, mySchema);\n')),(0,i.kt)("h3",{id:"output"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  result: { users: [ 1, 2 ] },\n  entities: {\n    users: {\n      '1': { id: 1 },\n      '2': { id: 2 }\n    }\n  }\n}\n")),(0,i.kt)("h2",{id:"denormalizeinput-schema-entities"},(0,i.kt)("inlineCode",{parentName:"h2"},"denormalize(input, schema, entities)")),(0,i.kt)("p",null,"Denormalizes an input based on schema and provided entities from a plain object or Immutable data. The reverse of ",(0,i.kt)("inlineCode",{parentName:"p"},"normalize"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Special Note:")," Be careful with denormalization. Prematurely reverting your data to large, nested objects could cause performance impacts in React (and other) applications."),(0,i.kt)("p",null,"If your schema and data have recursive references, only the first instance of an entity will be given. Subsequent references will be returned as the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," provided."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"input"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," The normalized result that should be ",(0,i.kt)("em",{parentName:"li"},"de-normalized"),". Usually the same value that was given in the ",(0,i.kt)("inlineCode",{parentName:"li"},"result")," key of the output of ",(0,i.kt)("inlineCode",{parentName:"li"},"normalize"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schema"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," A schema definition that was used to get the value for ",(0,i.kt)("inlineCode",{parentName:"li"},"input"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"entities"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," An object, keyed by entity schema names that may appear in the denormalized output. Also accepts an object with Immutable data.")),(0,i.kt)("h3",{id:"usage-1"},"Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { denormalize, schema } from "normalizr";\n\nconst user = new schema.Entity("users");\nconst mySchema = { users: [user] };\nconst entities = { users: { 1: { id: 1 }, 2: { id: 2 } } };\nconst denormalizedData = denormalize({ users: [1, 2] }, mySchema, entities);\n')),(0,i.kt)("h3",{id:"output-1"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  users: [{ id: 1 }, { id: 2 }];\n}\n")),(0,i.kt)("h2",{id:"schema"},(0,i.kt)("inlineCode",{parentName:"h2"},"schema")),(0,i.kt)("h3",{id:"arraydefinition-schemaattribute"},(0,i.kt)("inlineCode",{parentName:"h3"},"Array(definition, schemaAttribute)")),(0,i.kt)("p",null,"Creates a schema to normalize an array of schemas. If the input value is an ",(0,i.kt)("inlineCode",{parentName:"p"},"Object")," instead of an ",(0,i.kt)("inlineCode",{parentName:"p"},"Array"),", the normalized result will be an ",(0,i.kt)("inlineCode",{parentName:"p"},"Array")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Object"),"'s values."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note: The same behavior can be defined with shorthand syntax: ",(0,i.kt)("inlineCode",{parentName:"em"},"[ mySchema ]"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"definition"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," A singular schema that this array contains ",(0,i.kt)("em",{parentName:"li"},"or")," a mapping of schema to attribute values."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schemaAttribute"),": ",(0,i.kt)("em",{parentName:"li"},"optional")," (required if ",(0,i.kt)("inlineCode",{parentName:"li"},"definition")," is not a singular schema) The attribute on each entity found that defines what schema, per the definition mapping, to use when normalizing.",(0,i.kt)("br",{parentName:"li"}),"Can be a string or a function. If given a function, accepts the following arguments:",(0,i.kt)("br",{parentName:"li"}),"",(0,i.kt)("em",{parentName:"li"}," ",(0,i.kt)("inlineCode",{parentName:"em"},"value"),": The input value of the entity.\n")," ",(0,i.kt)("inlineCode",{parentName:"li"},"parent"),": The parent object of the input array. ","*"," ",(0,i.kt)("inlineCode",{parentName:"li"},"key"),": The key at which the input array appears on the parent object.")),(0,i.kt)("h4",{id:"instance-methods"},"Instance Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"define(definition)"),": When used, the ",(0,i.kt)("inlineCode",{parentName:"li"},"definition")," passed in will be merged with the original definition passed to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Array")," constructor. This method tends to be useful for creating circular references in schema.")),(0,i.kt)("h4",{id:"usage-2"},"Usage"),(0,i.kt)("p",null,"To describe a simple array of a singular entity type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const data = [\n  { id: "123", name: "Jim" },\n  { id: "456", name: "Jane" },\n];\nconst userSchema = new schema.Entity("users");\n\nconst userListSchema = new schema.Array(userSchema);\n// or use shorthand syntax:\nconst userListSchema = [userSchema];\n\nconst normalizedData = normalize(data, userListSchema);\n')),(0,i.kt)("h4",{id:"output-2"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entities: {\n    users: {\n      '123': { id: '123', name: 'Jim' },\n      '456': { id: '456', name: 'Jane' }\n    }\n  },\n  result: [ '123', '456' ]\n}\n")),(0,i.kt)("p",null,"If your input data is an array of more than one type of entity, it is necessary to define a schema mapping."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note: If your data returns an object that you did not provide a mapping for, the original object will be returned in the result and an entity will not be created.")),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const data = [\n  { id: 1, type: "admin" },\n  { id: 2, type: "user" },\n];\n\nconst userSchema = new schema.Entity("users");\nconst adminSchema = new schema.Entity("admins");\nconst myArray = new schema.Array(\n  {\n    admins: adminSchema,\n    users: userSchema,\n  },\n  (input, parent, key) => `${input.type}s`\n);\n\nconst normalizedData = normalize(data, myArray);\n')),(0,i.kt)("h4",{id:"output-3"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entities: {\n    admins: { '1': { id: 1, type: 'admin' } },\n    users: { '2': { id: 2, type: 'user' } }\n  },\n  result: [\n    { id: 1, schema: 'admins' },\n    { id: 2, schema: 'users' }\n  ]\n}\n")),(0,i.kt)("h3",{id:"entitykey-definition---options--"},(0,i.kt)("inlineCode",{parentName:"h3"},"Entity(key, definition = {}, options = {})")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," The key name under which all entities of this type will be listed in the normalized response. Must be a string name."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"definition"),": A definition of the nested entities found within this entity. Defaults to empty object.",(0,i.kt)("br",{parentName:"li"}),"You ",(0,i.kt)("em",{parentName:"li"},"do not")," need to define any keys in your entity other than those that hold nested entities. All other values will be copied to the normalized entity's output."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"options"),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"idAttribute"),": The attribute where unique IDs for each of this entity type can be found.",(0,i.kt)("br",{parentName:"li"}),"Accepts either a string ",(0,i.kt)("inlineCode",{parentName:"li"},"key")," or a function that returns the IDs ",(0,i.kt)("inlineCode",{parentName:"li"},"value"),". Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"'id'"),".",(0,i.kt)("br",{parentName:"li"}),"As a function, accepts the following arguments, in order:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value"),": The input value of the entity."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parent"),": The parent object of the input array."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key"),": The key at which the input array appears on the parent object."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mergeStrategy(entityA, entityB)"),": Strategy to use when merging two entities with the same ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," value. Defaults to merge the more recently found entity onto the previous."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"processStrategy(value, parent, key)"),": Strategy to use when pre-processing the entity. Use this method to add extra data, defaults, and/or completely change the entity before normalization is complete. Defaults to returning a shallow copy of the input entity.",(0,i.kt)("br",{parentName:"li"}),(0,i.kt)("em",{parentName:"li"},"Note: It is recommended to always return a copy of your input and not modify the original."),(0,i.kt)("br",{parentName:"li"}),"The function accepts the following arguments, in order:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value"),": The input value of the entity."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parent"),": The parent object of the input array."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key"),": The key at which the input array appears on the parent object."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fallbackStrategy(key, schema)"),": Strategy to use when denormalizing data structures with id references to missing entities.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key"),": The key at which the input array appears on the parent object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schema"),": The schema of the missing entity")))))),(0,i.kt)("h4",{id:"instance-methods-1"},"Instance Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"define(definition)"),": When used, the ",(0,i.kt)("inlineCode",{parentName:"li"},"definition")," passed in will be merged with the original definition passed to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Entity")," constructor. This method tends to be useful for creating circular references in schema.")),(0,i.kt)("h4",{id:"instance-attributes"},"Instance Attributes"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key"),": Returns the key provided to the constructor."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"idAttribute"),": Returns the idAttribute provided to the constructor in options.")),(0,i.kt)("h4",{id:"usage-3"},"Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const data = {\n  id_str: "123",\n  url: "https://twitter.com",\n  user: { id_str: "456", name: "Jimmy" },\n};\n\nconst user = new schema.Entity("users", {}, { idAttribute: "id_str" });\nconst tweet = new schema.Entity(\n  "tweets",\n  { user: user },\n  {\n    idAttribute: "id_str",\n    // Apply everything from entityB over entityA, except for "favorites"\n    mergeStrategy: (entityA, entityB) => ({\n      ...entityA,\n      ...entityB,\n      favorites: entityA.favorites,\n    }),\n    // Remove the URL field from the entity\n    processStrategy: (entity) => omit(entity, "url"),\n  }\n);\n\nconst normalizedData = normalize(data, tweet);\n')),(0,i.kt)("h4",{id:"output-4"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entities: {\n    tweets: { '123': { id_str: '123', user: '456' } },\n    users: { '456': { id_str: '456', name: 'Jimmy' } }\n  },\n  result: '123'\n}\n")),(0,i.kt)("h4",{id:"idattribute-usage"},(0,i.kt)("inlineCode",{parentName:"h4"},"idAttribute")," Usage"),(0,i.kt)("p",null,"When passing the ",(0,i.kt)("inlineCode",{parentName:"p"},"idAttribute")," a function, it should return the IDs value."),(0,i.kt)("p",null,"For Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const data = [\n  { id: "1", guest_id: null, name: "Esther" },\n  { id: "1", guest_id: "22", name: "Tom" },\n];\n\nconst patronsSchema = new schema.Entity("patrons", undefined, {\n  // idAttribute *functions* must return the ids **value** (not key)\n  idAttribute: (value) =>\n    value.guest_id ? `${value.id}-${value.guest_id}` : value.id,\n});\n\nnormalize(data, [patronsSchema]);\n')),(0,i.kt)("h4",{id:"output-5"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entities: {\n    patrons: {\n      '1': { id: '1', guest_id: null, name: 'Esther' },\n      '1-22': { id: '1', guest_id: '22', name: 'Tom' },\n    }\n  },\n  result: ['1', '1-22']\n}\n")),(0,i.kt)("h4",{id:"fallbackstrategy-usage"},(0,i.kt)("inlineCode",{parentName:"h4"},"fallbackStrategy")," Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const users = {\n  1: { id: "1", name: "Emily", requestState: "SUCCEEDED" },\n  2: { id: "2", name: "Douglas", requestState: "SUCCEEDED" },\n};\nconst books = {\n  1: { id: "1", name: "Book 1", authors: 1 },\n  2: { id: "2", name: "Book 2", authors: 2 },\n  3: { id: "3", name: "Book 3", authors: 3 },\n};\n\nconst authorSchema = new schema.Entity(\n  "authors",\n  {},\n  {\n    fallbackStrategy: (key, schema) => {\n      return {\n        [schema.idAttribute]: key,\n        name: "Unknown",\n        requestState: "NONE",\n      };\n    },\n  }\n);\nconst bookSchema = new schema.Entity("books", {\n  authors: authorSchema,\n});\n\ndenormalize([1, 2, 3], [bookSchema], {\n  books,\n  authors: users,\n});\n')),(0,i.kt)("h4",{id:"output-6"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'[\n  {\n    id: "1",\n    name: "Book 1",\n    authors: { id: "1", name: "Emily", requestState: "SUCCEEDED" },\n  },\n  {\n    id: "2",\n    name: "Book 2",\n    authors: { id: "2", name: "Douglas", requestState: "SUCCEEDED" },\n  },\n  {\n    id: "3",\n    name: "Book 3",\n    authors: { id: "3", name: "Unknown", requestState: "NONE" },\n  },\n];\n')),(0,i.kt)("h3",{id:"objectdefinition"},(0,i.kt)("inlineCode",{parentName:"h3"},"Object(definition)")),(0,i.kt)("p",null,"Define a plain object mapping that has values needing to be normalized into Entities. ",(0,i.kt)("em",{parentName:"p"},"Note: The same behavior can be defined with shorthand syntax: ",(0,i.kt)("inlineCode",{parentName:"em"},"{ ... }"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"definition"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," A definition of the nested entities found within this object. Defaults to empty object.",(0,i.kt)("br",{parentName:"li"}),"You ",(0,i.kt)("em",{parentName:"li"},"do not")," need to define any keys in your object other than those that hold other entities. All other values will be copied to the normalized output.")),(0,i.kt)("h4",{id:"instance-methods-2"},"Instance Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"define(definition)"),": When used, the ",(0,i.kt)("inlineCode",{parentName:"li"},"definition")," passed in will be merged with the original definition passed to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Object")," constructor. This method tends to be useful for creating circular references in schema.")),(0,i.kt)("h4",{id:"usage-4"},"Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// Example data response\nconst data = { users: [{ id: "123", name: "Beth" }] };\n\nconst user = new schema.Entity("users");\nconst responseSchema = new schema.Object({ users: new schema.Array(user) });\n// or shorthand\nconst responseSchema = { users: new schema.Array(user) };\n\nconst normalizedData = normalize(data, responseSchema);\n')),(0,i.kt)("h4",{id:"output-7"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entities: {\n    users: { '123': { id: '123', name: 'Beth' } }\n  },\n  result: { users: [ '123' ] }\n}\n")),(0,i.kt)("h3",{id:"uniondefinition-schemaattribute"},(0,i.kt)("inlineCode",{parentName:"h3"},"Union(definition, schemaAttribute)")),(0,i.kt)("p",null,"Describe a schema which is a union of multiple schemas. This is useful if you need the polymorphic behavior provided by ",(0,i.kt)("inlineCode",{parentName:"p"},"schema.Array")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"schema.Values")," but for non-collection fields."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"definition"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," An object mapping the definition of the nested entities found within the input array"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schemaAttribute"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," The attribute on each entity found that defines what schema, per the definition mapping, to use when normalizing.",(0,i.kt)("br",{parentName:"li"}),"Can be a string or a function. If given a function, accepts the following arguments:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value"),": The input value of the entity."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parent"),": The parent object of the input array."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key"),": The key at which the input array appears on the parent object.")))),(0,i.kt)("h4",{id:"instance-methods-3"},"Instance Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"define(definition)"),": When used, the ",(0,i.kt)("inlineCode",{parentName:"li"},"definition")," passed in will be merged with the original definition passed to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Union")," constructor. This method tends to be useful for creating circular references in schema.")),(0,i.kt)("h4",{id:"usage-5"},"Usage"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note: If your data returns an object that you did not provide a mapping for, the original object will be returned in the result and an entity will not be created.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const data = { owner: { id: 1, type: "user", name: "Anne" } };\n\nconst user = new schema.Entity("users");\nconst group = new schema.Entity("groups");\nconst unionSchema = new schema.Union(\n  {\n    user: user,\n    group: group,\n  },\n  "type"\n);\n\nconst normalizedData = normalize(data, { owner: unionSchema });\n')),(0,i.kt)("h4",{id:"output-8"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entities: {\n    users: { '1': { id: 1, type: 'user', name: 'Anne' } }\n  },\n  result: { owner: { id: 1, schema: 'user' } }\n}\n")),(0,i.kt)("h3",{id:"valuesdefinition-schemaattribute"},(0,i.kt)("inlineCode",{parentName:"h3"},"Values(definition, schemaAttribute)")),(0,i.kt)("p",null,"Describes a map whose values follow the given schema."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"definition"),": ",(0,i.kt)("strong",{parentName:"li"},"required")," A singular schema that this array contains ",(0,i.kt)("em",{parentName:"li"},"or")," a mapping of schema to attribute values."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schemaAttribute"),": ",(0,i.kt)("em",{parentName:"li"},"optional")," (required if ",(0,i.kt)("inlineCode",{parentName:"li"},"definition")," is not a singular schema) The attribute on each entity found that defines what schema, per the definition mapping, to use when normalizing.",(0,i.kt)("br",{parentName:"li"}),"Can be a string or a function. If given a function, accepts the following arguments:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"value"),": The input value of the entity."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"parent"),": The parent object of the input array."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"key"),": The key at which the input array appears on the parent object.")))),(0,i.kt)("h4",{id:"instance-methods-4"},"Instance Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"define(definition)"),": When used, the ",(0,i.kt)("inlineCode",{parentName:"li"},"definition")," passed in will be merged with the original definition passed to the ",(0,i.kt)("inlineCode",{parentName:"li"},"Values")," constructor. This method tends to be useful for creating circular references in schema.")),(0,i.kt)("h4",{id:"usage-6"},"Usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const data = { firstThing: { id: 1 }, secondThing: { id: 2 } };\n\nconst item = new schema.Entity("items");\nconst valuesSchema = new schema.Values(item);\n\nconst normalizedData = normalize(data, valuesSchema);\n')),(0,i.kt)("h4",{id:"output-9"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entities: {\n    items: { '1': { id: 1 }, '2': { id: 2 } }\n  },\n  result: { firstThing: 1, secondThing: 2 }\n}\n")),(0,i.kt)("p",null,"If your input data is an object that has values of more than one type of entity, but their schema is not easily defined by the key, you can use a mapping of schema, much like ",(0,i.kt)("inlineCode",{parentName:"p"},"schema.Union")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"schema.Array"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note: If your data returns an object that you did not provide a mapping for, the original object will be returned in the result and an entity will not be created.")),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const data = {\n  1: { id: 1, type: "admin" },\n  2: { id: 2, type: "user" },\n};\n\nconst userSchema = new schema.Entity("users");\nconst adminSchema = new schema.Entity("admins");\nconst valuesSchema = new schema.Values(\n  {\n    admins: adminSchema,\n    users: userSchema,\n  },\n  (input, parent, key) => `${input.type}s`\n);\n\nconst normalizedData = normalize(data, valuesSchema);\n')),(0,i.kt)("h4",{id:"output-10"},"Output"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"{\n  entities: {\n    admins: { '1': { id: 1, type: 'admin' } },\n    users: { '2': { id: 2, type: 'user' } }\n  },\n  result: {\n    '1': { id: 1, schema: 'admins' },\n    '2': { id: 2, schema: 'users' }\n  }\n}\n")))}p.isMDXComponent=!0}}]);